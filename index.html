<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Діна збирає мушлі</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    body {
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    canvas {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #000;
    }
    #hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      color: #fff;
      font-family: sans-serif;
      font-size: 18px;
      background: rgba(60, 60, 60, 0.7);
      /* Safe area padding for notch (top, left, right) */
      padding-top: constant(safe-area-inset-top);
      padding-top: env(safe-area-inset-top);
      padding-right: calc(10px + constant(safe-area-inset-right));
      padding-right: calc(10px + env(safe-area-inset-right));
      padding-bottom: 5px;
      padding-left: calc(10px + constant(safe-area-inset-left));
      padding-left: calc(10px + env(safe-area-inset-left));
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    #hud-left span {
      margin-left: 8px;
    }
    #hud .timer-icon, #hud img {
      vertical-align: middle;
    }
    #soundIcon {
      width: 24px;
      height: 24px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    #controls {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      text-align: center;
      padding-bottom: constant(safe-area-inset-bottom);
      padding-bottom: env(safe-area-inset-bottom);
      box-sizing: border-box;
    }
    .ctrl-btn {
      display: inline-block;
      width: 18vw;
      max-width: 90px;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    .ctrl-btn:focus {
      outline: none;
    }
  </style>
</head>
<body>
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>

  <!-- Heads-Up Display (HUD) -->
  <div id="hud">
    <div id="hud-left">
      <img src="icons/shell.png" alt="Shell" />
      <span id="shellCount">0</span>
      <span id="timer">
        <span class="timer-icon">⏳</span>
        <span id="time">00:00</span>
      </span>
      <span id="level">Рівень: 1</span>
    </div>
    <img id="soundIcon" src="icons/sound-on.png" alt="Sound" />
  </div>

  <!-- On-screen Controls -->
  <div id="controls">
    <img src="icons/left.png" id="leftBtn" class="ctrl-btn" alt="Left" />
    <img src="icons/up.png" id="upBtn" class="ctrl-btn" alt="Up" />
    <img src="icons/down.png" id="downBtn" class="ctrl-btn" alt="Down" />
    <img src="icons/right.png" id="rightBtn" class="ctrl-btn" alt="Right" />
  </div>

  <!-- Background Music -->
  <audio id="bgMusic" src="music/yachting-song.MP3" loop></audio>

  <script>
    // Canvas setup for full-screen 9:16 aspect ratio
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let gameWidth, gameHeight;
    let visibleWidth, visibleHeight;
    let offsetX = 0, offsetY = 0;

    function resizeCanvas() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const targetAspect = 9 / 16;
      let newWidth, newHeight;
      if (w / h < targetAspect) {
        // Screen is taller/narrower than 9:16 – use full height, extend width
        newHeight = h;
        newWidth = h * targetAspect;
      } else {
        // Screen is wider than 9:16 – use full width, extend height
        newWidth = w;
        newHeight = w * (16 / 9);
      }
      // Adjust for device pixel ratio for sharpness
      const ratio = window.devicePixelRatio || 1;
      canvas.width = newWidth * ratio;
      canvas.height = newHeight * ratio;
      canvas.style.width = newWidth + 'px';
      canvas.style.height = newHeight + 'px';
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      // Save canvas and visible dimensions
      gameWidth = newWidth;
      gameHeight = newHeight;
      visibleWidth = w;
      visibleHeight = h;
      // Compute offset (cropped) to center canvas content on screen
      offsetX = (gameWidth - visibleWidth) / 2;
      offsetY = (gameHeight - visibleHeight) / 2;
    }

    // Initial sizing and update on window resize/orientation change
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Load images and assets
    const playerImg = new Image();
    playerImg.src = 'icons/dina.png';
    const shellImg = new Image();
    shellImg.src = 'icons/shell.png';
    const yachtImg = new Image();
    yachtImg.src = 'yachts/yacht1.png';
    // Preload background images for levels 1-6
    const bgImages = [];
    for (let i = 1; i <= 6; i++) {
      bgImages[i] = new Image();
      bgImages[i].src = 'backgrounds/bg' + i + '.jpg';
    }
    // Sound icon image paths (for toggling)
    const soundOnImg = 'icons/sound-on.png';
    const soundOffImg = 'icons/sound-off.png';

    // Game state variables
    let level = 1;
    let lastTime = null;
    let shellsCollected = 0;
    let timerSeconds = 0;
    let isSoundOn = true;

    // Player (Dina) properties
    let dinaX, dinaY;
    let dinaScale = 1;
    const baseDinaScale = 1;
    const maxDinaScale = 3;
    const dinaSpeed = 4;  // Dina movement speed (pixels per frame)

    // Yacht (enemy) properties
    let yachtX, yachtY;
    let yachtSpeed = 2;   // initial yacht speed, increases each level

    // Shell (collectible) properties
    let shellX, shellY;
    let shellPresent = false;

    // Movement control flags
    let moveUp = false, moveDown = false, moveLeft = false, moveRight = false;

    // Format time as MM:SS
    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return (m < 10 ? '0' + m : m) + ':' + (s < 10 ? '0' + s : s);
    }

    // HUD elements for dynamic updates
    const timeElem = document.getElementById('time');
    const shellCountElem = document.getElementById('shellCount');
    const levelElem = document.getElementById('level');

    function updateTimerDisplay() {
      timeElem.textContent = formatTime(timerSeconds);
    }
    function updateHUD() {
      shellCountElem.textContent = shellsCollected;
      levelElem.textContent = 'Рівень: ' + level;
    }

    // Spawn a shell at a random position within visible game area (with margins)
    function spawnShell() {
      const margin = 20;
      const xRange = visibleWidth - margin * 2;
      const yRange = visibleHeight - margin * 2;
      shellX = offsetX + margin + Math.random() * xRange;
      shellY = offsetY + margin + Math.random() * yRange;
      shellPresent = true;
    }

    // Initialize yacht at a random edge of the visible area
    function initYachtPosition() {
      const edge = Math.floor(Math.random() * 4);
      const margin = 50;
      if (edge === 0) { // left edge
        yachtX = offsetX - margin;
        yachtY = offsetY + Math.random() * visibleHeight;
      } else if (edge === 1) { // right edge
        yachtX = offsetX + visibleWidth + margin;
        yachtY = offsetY + Math.random() * visibleHeight;
      } else if (edge === 2) { // top edge
        yachtY = offsetY - margin;
        yachtX = offsetX + Math.random() * visibleWidth;
      } else if (edge === 3) { // bottom edge
        yachtY = offsetY + visibleHeight + margin;
        yachtX = offsetX + Math.random() * visibleWidth;
      }
    }

    // Set current level (update speed and background)
    function setLevel(newLevel) {
      if (newLevel > 6) newLevel = 6;
      level = newLevel;
      yachtSpeed = 2 + (level - 1) * 0.5;  // increase yacht speed each level
      currentBg = bgImages[level];        // switch background image
      updateHUD();
    }

    // Initialize Dina's position and scale at center of screen
    function initDina() {
      dinaX = offsetX + visibleWidth / 2;
      dinaY = offsetY + visibleHeight / 2;
      dinaScale = baseDinaScale;
    }

    // Control input handlers for on-screen buttons
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const upBtn = document.getElementById('upBtn');
    const downBtn = document.getElementById('downBtn');

    function onPointerDown(direction) {
      switch (direction) {
        case 'left':  moveLeft = true; break;
        case 'right': moveRight = true; break;
        case 'up':    moveUp = true; break;
        case 'down':  moveDown = true; break;
      }
      startAudio();  // start music on first interaction
    }
    function onPointerUp(direction) {
      switch (direction) {
        case 'left':  moveLeft = false; break;
        case 'right': moveRight = false; break;
        case 'up':    moveUp = false; break;
        case 'down':  moveDown = false; break;
      }
    }

    // Use Pointer Events if supported (for multi-touch), otherwise fallback to touch/mouse events
    if (window.PointerEvent) {
      [leftBtn, rightBtn, upBtn, downBtn].forEach(btn => {
        const dir = btn.id.replace('Btn', '');  // e.g., "leftBtn" -> "left"
        btn.addEventListener('pointerdown', e => {
          e.preventDefault();
          onPointerDown(dir);
        });
        btn.addEventListener('pointerup', e => {
          e.preventDefault();
          onPointerUp(dir);
        });
        btn.addEventListener('pointerleave', () => onPointerUp(dir));
        btn.addEventListener('pointercancel', () => onPointerUp(dir));
      });
    } else {
      // Touch and Mouse events fallback
      [leftBtn, rightBtn, upBtn, downBtn].forEach(btn => {
        const dir = btn.id.replace('Btn', '');
        btn.addEventListener('mousedown', e => {
          e.preventDefault();
          onPointerDown(dir);
        });
        btn.addEventListener('mouseup', () => onPointerUp(dir));
        btn.addEventListener('mouseleave', () => onPointerUp(dir));
        btn.addEventListener('touchstart', e => {
          e.preventDefault();
          onPointerDown(dir);
        });
        btn.addEventListener('touchend', () => onPointerUp(dir));
        btn.addEventListener('touchcancel', () => onPointerUp(dir));
      });
    }

    // Keyboard controls for desktop (arrow keys)
    window.addEventListener('keydown', e => {
      switch (e.key) {
        case 'ArrowLeft':  moveLeft = true;  startAudio(); break;
        case 'ArrowRight': moveRight = true; startAudio(); break;
        case 'ArrowUp':    moveUp = true;    startAudio(); break;
        case 'ArrowDown':  moveDown = true;  startAudio(); break;
      }
    });
    window.addEventListener('keyup', e => {
      switch (e.key) {
        case 'ArrowLeft':  moveLeft = false; break;
        case 'ArrowRight': moveRight = false; break;
        case 'ArrowUp':    moveUp = false; break;
        case 'ArrowDown':  moveDown = false; break;
      }
    });

    // Sound toggle control
    const bgMusic = document.getElementById('bgMusic');
    const soundIcon = document.getElementById('soundIcon');
    soundIcon.addEventListener('click', () => {
      if (isSoundOn) {
        // Turn sound off
        isSoundOn = false;
        soundIcon.src = soundOffImg;
        if (!bgMusic.paused) bgMusic.pause();
      } else {
        // Turn sound on
        isSoundOn = true;
        soundIcon.src = soundOnImg;
        if (firstInteractionHappened) {
          bgMusic.play();
        }
      }
    });

    // Prepare audio (will play on first interaction due to browser auto-play policy)
    bgMusic.volume = 1.0;
    let firstInteractionHappened = false;
    function startAudio() {
      if (!firstInteractionHappened) {
        firstInteractionHappened = true;
        if (isSoundOn) {
          // Try to play music (will work only if triggered by user gesture)
          bgMusic.play().catch(err => {
            // Autoplay might be blocked until user interacts again
          });
        }
      }
    }

    // Disable context menu (prevent right-click or long-press menus)
    window.addEventListener('contextmenu', e => e.preventDefault());

    // Game loop variables
    let currentBg = bgImages[1];  // current background image (level-based)
    // Game loop using requestAnimationFrame
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      // Draw background (cover entire canvas)
      if (currentBg && currentBg.complete) {
        ctx.drawImage(currentBg, 0, 0, gameWidth, gameHeight);
      } else {
        // If image not yet loaded, fill with black
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, gameWidth, gameHeight);
      }

      // Update Dina's position based on input
      let dx = 0, dy = 0;
      if (moveLeft)  dx -= 1;
      if (moveRight) dx += 1;
      if (moveUp)    dy -= 1;
      if (moveDown)  dy += 1;
      // Normalize diagonal movement so speed remains consistent
      if (dx !== 0 && dy !== 0) {
        dx *= Math.SQRT1_2;
        dy *= Math.SQRT1_2;
      }
      // Move Dina by her speed
      dinaX += dx * dinaSpeed;
      dinaY += dy * dinaSpeed;
      // Prevent Dina from going out of visible bounds (keep fully on screen)
      if (dinaX < offsetX + (playerImg.width * dinaScale) / 2) {
        dinaX = offsetX + (playerImg.width * dinaScale) / 2;
      }
      if (dinaX > offsetX + visibleWidth - (playerImg.width * dinaScale) / 2) {
        dinaX = offsetX + visibleWidth - (playerImg.width * dinaScale) / 2;
      }
      if (dinaY < offsetY + (playerImg.height * dinaScale) / 2) {
        dinaY = offsetY + (playerImg.height * dinaScale) / 2;
      }
      if (dinaY > offsetY + visibleHeight - (playerImg.height * dinaScale) / 2) {
        dinaY = offsetY + visibleHeight - (playerImg.height * dinaScale) / 2;
      }

      // Move yacht toward the current shell if it exists
      if (shellPresent) {
        const dxBoat = shellX - yachtX;
        const dyBoat = shellY - yachtY;
        const distBoat = Math.hypot(dxBoat, dyBoat);
        if (distBoat < yachtSpeed) {
          // Close enough to reach this frame
          yachtX = shellX;
          yachtY = shellY;
        } else {
          // Move toward shell
          yachtX += (dxBoat / distBoat) * yachtSpeed;
          yachtY += (dyBoat / distBoat) * yachtSpeed;
        }
      }

      // Check collisions if a shell is present
      if (shellPresent) {
        const dxShell = shellX - dinaX;
        const dyShell = shellY - dinaY;
        const distShell = Math.hypot(dxShell, dyShell);
        // Determine collision radii (approximate as circles)
        let dinaRadius = playerImg.complete ? (playerImg.width * dinaScale) / 2 : 20 * dinaScale;
        let shellRadius = shellImg.complete ? shellImg.width / 2 : 10;
        if (distShell < dinaRadius + shellRadius) {
          // Dina collects the shell
          shellsCollected++;
          shellPresent = false;
          // Grow Dina up to 3x size
          dinaScale = Math.min(maxDinaScale, dinaScale + 0.4);
          // Check for level up
          const newLevel = Math.min(6, Math.floor(shellsCollected / 5) + 1);
          if (newLevel !== level) {
            setLevel(newLevel);
            // Re-center Dina at start of new level
            dinaX = offsetX + visibleWidth / 2;
            dinaY = offsetY + visibleHeight / 2;
          }
          updateHUD();
          // Spawn the next shell after a short delay
          setTimeout(spawnShell, 500);
        }
        // If shell still present (not already taken by Dina)
        if (shellPresent) {
          let yachtRadius = yachtImg.complete ? yachtImg.width / 2 : 30;
          if (distShell < yachtRadius + shellRadius) {
            // Yacht reaches the shell first – Dina loses this bonus
            shellPresent = false;
            // Spawn next shell after a short delay
            setTimeout(spawnShell, 500);
          }
        }
      }

      // Draw shell
      if (shellPresent && shellImg.complete) {
        ctx.drawImage(shellImg, shellX - shellImg.width / 2, shellY - shellImg.height / 2);
      }
      // Draw yacht
      if (yachtImg.complete) {
        ctx.drawImage(yachtImg, yachtX - yachtImg.width / 2, yachtY - yachtImg.height / 2);
      }
      // Draw Dina (player)
      if (playerImg.complete) {
        const pWidth = playerImg.width * dinaScale;
        const pHeight = playerImg.height * dinaScale;
        ctx.drawImage(playerImg, dinaX - pWidth / 2, dinaY - pHeight / 2, pWidth, pHeight);
      } else {
        // If Dina's image not loaded yet, draw a placeholder circle
        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(dinaX, dinaY, 20 * dinaScale, 0, 2 * Math.PI);
        ctx.fill();
      }

      // Loop the game
      requestAnimationFrame(gameLoop);
    }

    // Start the game
    initDina();
    initYachtPosition();
    spawnShell();
    updateHUD();
    // Start the timer
    setInterval(() => {
      timerSeconds++;
      updateTimerDisplay();
    }, 1000);
    // Start the game loop
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
