<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Діна збирає мушлі</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            touch-action: none;
            z-index: 1;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.75);
            padding: 10px 20px;
            border-radius: 30px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 600;
            margin: 0 10px;
            min-width: fit-content;
            white-space: nowrap;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.2s ease;
        }

        .hud-item:hover {
            transform: translateY(-2px);
        }

        .level-text {
            margin-left: 20px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
            padding-left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #levelText {
            background: rgba(255, 255, 255, 0.15);
            padding: 2px 10px;
            border-radius: 15px;
            min-width: 30px;
            text-align: center;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 2;
            color: white;
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transform: none;
        }

        .hud-icon {
            width: 32px;
            height: 32px;
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
            flex-shrink: 0;
            transition: transform 0.2s ease;
        }

        .hud-item:hover .hud-icon {
            transform: scale(1.1);
        }

        #controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 35px;
            z-index: 2;
        }

        .control-btn {
            width: 85px;
            height: 85px;
            background: rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .control-btn img {
            width: 55px;
            height: 55px;
            pointer-events: none;
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
            transition: transform 0.2s ease;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .control-btn:active img {
            transform: scale(0.95);
        }

        #soundToggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            cursor: pointer;
            z-index: 3;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            padding: 10px;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #soundToggle:hover {
            transform: scale(1.1);
            background: rgba(0, 0, 0, 0.7);
        }

        #soundToggle:active {
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            .hud-item {
                font-size: 18px;
                padding: 8px 16px;
                gap: 8px;
            }

            .hud-icon {
                width: 24px;
                height: 24px;
            }

            #hud {
                padding: 10px;
            }

            .level-text {
                margin-left: 10px;
                padding-left: 10px;
                font-size: 16px;
            }

            #levelText {
                padding: 2px 8px;
                min-width: 24px;
            }

            #controls {
                bottom: 30px;
                gap: 25px;
            }

            .control-btn {
                width: 75px;
                height: 75px;
            }

            .control-btn img {
                width: 45px;
                height: 45px;
            }
        }

        @media (max-width: 480px) {
            .hud-item {
                font-size: 16px;
                padding: 6px 12px;
                gap: 6px;
                margin: 0 5px;
            }

            .hud-icon {
                width: 20px;
                height: 20px;
            }

            #hud {
                padding: 8px;
            }

            .level-text {
                margin-left: 8px;
                padding-left: 8px;
                font-size: 14px;
            }

            #levelText {
                padding: 2px 6px;
                min-width: 20px;
            }

            #controls {
                gap: 20px;
                bottom: 20px;
            }

            .control-btn {
                width: 65px;
                height: 65px;
            }

            .control-btn img {
                width: 40px;
                height: 40px;
            }

            #soundToggle {
                top: 10px;
                right: 10px;
                width: 40px;
                height: 40px;
                padding: 8px;
            }
        }

        @media (max-width: 360px) {
            .hud-item {
                font-size: 14px;
                padding: 4px 10px;
                gap: 4px;
                margin: 0 3px;
            }

            .hud-icon {
                width: 18px;
                height: 18px;
            }

            .level-text {
                margin-left: 6px;
                padding-left: 6px;
                font-size: 13px;
            }

            #levelText {
                padding: 1px 5px;
                min-width: 18px;
            }

            #controls {
                gap: 15px;
            }

            .control-btn {
                width: 55px;
                height: 55px;
            }

            .control-btn img {
                width: 35px;
                height: 35px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div class="hud-item">
                <img src="./icons/shell.png" class="hud-icon" alt="Shell">
                <span id="scoreText">0</span>
            </div>
            <div class="hud-item">
                <img src="./icons/hourglass.png" class="hud-icon" alt="Timer">
                <span id="timeText">00:00</span>
                <span class="level-text">Рівень: <span id="levelText">1</span></span>
            </div>
        </div>
        <button id="soundToggle">
            <img src="./icons/sound-on.png" alt="Sound">
        </button>
        <div id="controls">
            <div class="control-btn" id="btnLeft">
                <img src="./icons/left.png" alt="Left">
            </div>
            <div class="control-btn" id="btnUp">
                <img src="./icons/up.png" alt="Up">
            </div>
            <div class="control-btn" id="btnDown">
                <img src="./icons/down.png" alt="Down">
            </div>
            <div class="control-btn" id="btnRight">
                <img src="./icons/right.png" alt="Right">
            </div>
        </div>
    </div>

    <script>
        // Константы игры
        const ASPECT_RATIO = 9/16;
        const MAX_LEVEL = 6;
        const SHELLS_PER_LEVEL = 5;
        const MIN_SHELL_SPAWN_INTERVAL = 1000;
        const LEVEL_DURATION = 60;
        const SPEED_BOOST_TIME = 10;
        const SPEED_BOOST_MULTIPLIER = 2;

        // Игровые переменные
        let gameWidth, gameHeight;
        let gameOffsetX, gameOffsetY;
        let shellsCollected = 0;
        let level = 1;
        let timeElapsed = 0;
        let levelTimeElapsed = 0; // Время, прошедшее на текущем уровне
        let lastShellSpawnTime = 0;
        let isSpeedBoosted = false;

        // Состояние игры
        let isGameRunning = false;
        let soundEnabled = true;
        
        // Параметры объектов
        const DINA_CONFIG = {
            baseSize: 48,
            speed: 5,
            minScale: 1,
            maxScale: 1.2,
            scaleIncrement: 0.02,
            // Параметры анимации
            frames: 8,              // количество кадров в спрайтшите
            frameWidth: 48,         // ширина одного кадра
            frameHeight: 48,        // высота одного кадра
            animationSpeed: 100,    // миллисекунды между кадрами
            facingLeft: false       // направление движения
        };

        const YACHT_CONFIG = {
            width: 180,
            height: 108,
            baseSpeed: 2,
            speedIncrement: 0.1,
            interpolation: 0.01
        };

        const SHELL_CONFIG = {
            size: 32
        };

        // Объекты игры
        let dina = {
            x: 0,
            y: 0,
            scale: DINA_CONFIG.minScale,
            currentFrame: 0,        // текущий кадр анимации
            lastFrameUpdate: 0,     // время последнего обновления кадра
            isMoving: false         // двигается ли персонаж
        };

        let yacht = {
            x: 0,
            y: 0,
            speed: YACHT_CONFIG.baseSpeed
        };

        let shell = {
            x: 0,
            y: 0,
            active: false
        };

        // Управление
        let controls = {
            left: false,
            right: false,
            up: false,
            down: false
        };

        // Загрузка ресурсов с отладкой
        const resources = {
            dina: new Image(),
            yacht: new Image(),
            shell: new Image(),
            backgrounds: Array(MAX_LEVEL).fill(null).map(() => new Image()),
            audio: new Audio('./music/yachting-song.MP3')
        };

        // Инициализация canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Функция для проверки загрузки изображения
        function checkImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    console.log(`Image loaded successfully: ${url}`);
                    resolve(true);
                };
                img.onerror = (error) => {
                    console.error(`Failed to load image: ${url}`, error);
                    resolve(false);
                };
                img.src = url;
            });
        }

        async function initGame() {
            console.log('Game initialization started');
            
            // Загружаем ресурсы с проверкой и обработкой ошибок
            resources.dina.onload = () => console.log('Dina sprite loaded successfully');
            resources.dina.onerror = (e) => console.error('Failed to load Dina sprite:', e);
            resources.dina.src = './icons/dina.png';
            
            resources.shell.onload = () => console.log('Shell sprite loaded successfully');
            resources.shell.onerror = (e) => console.error('Failed to load shell sprite:', e);
            resources.shell.src = './icons/shell.png';
            
            resources.yacht.onload = () => console.log('Yacht loaded successfully');
            resources.yacht.onerror = (e) => console.error('Failed to load yacht:', e);
            resources.yacht.src = './icons/yacht1.png';

            resources.backgrounds.forEach((bg, i) => {
                bg.onload = () => console.log(`Background ${i + 1} loaded successfully`);
                bg.onerror = (e) => console.error(`Failed to load background ${i + 1}:`, e);
                bg.src = `./backgrounds/bg${i + 1}.jpg`;
            });

            // Инициализируем размеры
            calculateGameBoundaries();
            window.addEventListener('resize', calculateGameBoundaries);

            // Размещаем Дину в центре
            resetDinaPosition();
            
            // Проверяем наличие файлов перед запуском
            const resourceChecks = [
                checkImage('./icons/dina.png'),
                checkImage('./icons/yacht1.png'),
                checkImage('./icons/shell.png'),
                ...Array(MAX_LEVEL).fill().map((_, i) => checkImage(`./backgrounds/bg${i + 1}.jpg`))
            ];

            const results = await Promise.all(resourceChecks);
            const missingResources = results.some(result => !result);

            if (missingResources) {
                console.error('Some resources failed to load. Check file paths and permissions.');
                // Добавляем сообщение об ошибке на экран
                const errorMsg = document.createElement('div');
                errorMsg.style.position = 'absolute';
                errorMsg.style.top = '50%';
                errorMsg.style.left = '50%';
                errorMsg.style.transform = 'translate(-50%, -50%)';
                errorMsg.style.color = 'white';
                errorMsg.style.fontSize = '20px';
                errorMsg.style.textAlign = 'center';
                errorMsg.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                errorMsg.style.padding = '20px';
                errorMsg.style.borderRadius = '10px';
                errorMsg.style.zIndex = '1000';
                errorMsg.innerHTML = 'Помилка завантаження ресурсів гри.<br>Будь ласка, перезавантажте сторінку.';
                document.body.appendChild(errorMsg);
            } else {
                console.log('All resources loaded successfully');
                startGame();
            }
        }

        function startGame() {
            isGameRunning = true;
            spawnShell();
            startTimer();
            requestAnimationFrame(gameLoop);
        }

        function resetDinaPosition() {
            dina.x = gameOffsetX + gameWidth / 2;
            dina.y = gameOffsetY + gameHeight / 2;
            dina.scale = DINA_CONFIG.minScale;
        }

        function spawnShell() {
            const currentTime = Date.now();
            if (currentTime - lastShellSpawnTime < MIN_SHELL_SPAWN_INTERVAL) return;

            // Отступ от края игрового поля
            const margin = SHELL_CONFIG.size;
            
            // Размещаем ракушку только внутри игрового поля
            shell.x = gameOffsetX + margin + Math.random() * (gameWidth - SHELL_CONFIG.size - margin * 2);
            shell.y = gameOffsetY + margin + Math.random() * (gameHeight - SHELL_CONFIG.size - margin * 2);
            
            // Проверяем, что ракушка точно внутри игрового поля
            shell.x = Math.min(Math.max(shell.x, gameOffsetX), gameOffsetX + gameWidth - SHELL_CONFIG.size);
            shell.y = Math.min(Math.max(shell.y, gameOffsetY), gameOffsetY + gameHeight - SHELL_CONFIG.size);
            
            shell.active = true;
            
            // Сбрасываем позицию яхты только при первом запуске игры
            if (yacht.x === 0 && yacht.y === 0) {
                resetYachtPosition();
            }
            
            lastShellSpawnTime = currentTime;
        }

        function resetYachtPosition() {
            const edge = Math.floor(Math.random() * 4);
            const buffer = 20;
            
            switch(edge) {
                case 0: // left
                    yacht.x = gameOffsetX + buffer;
                    yacht.y = gameOffsetY + Math.random() * (gameHeight - YACHT_CONFIG.height);
                    break;
                case 1: // right
                    yacht.x = gameOffsetX + gameWidth - YACHT_CONFIG.width - buffer;
                    yacht.y = gameOffsetY + Math.random() * (gameHeight - YACHT_CONFIG.height);
                    break;
                case 2: // top
                    yacht.x = gameOffsetX + Math.random() * (gameWidth - YACHT_CONFIG.width);
                    yacht.y = gameOffsetY + buffer;
                    break;
                case 3: // bottom
                    yacht.x = gameOffsetX + Math.random() * (gameWidth - YACHT_CONFIG.width);
                    yacht.y = gameOffsetY + gameHeight - YACHT_CONFIG.height - buffer;
                    break;
            }

            yacht.speed = YACHT_CONFIG.baseSpeed + (level - 1) * YACHT_CONFIG.speedIncrement;
            
            // Добавляем отладочный вывод
            console.log('Yacht position:', { x: yacht.x, y: yacht.y, speed: yacht.speed });
        }

        function updateYacht() {
            if (!shell.active || !resources.yacht.complete) {
                return;
            }

            const dx = shell.x - (yacht.x + YACHT_CONFIG.width/2);
            const dy = shell.y - (yacht.y + YACHT_CONFIG.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Проверяем, достаточно ли близко яхта к ракушке для сбора
            const collectionDistance = YACHT_CONFIG.width/3;
            
            if (distance < collectionDistance) {
                // Яхта собирает ракушку
                shell.active = false;
                setTimeout(spawnShell, MIN_SHELL_SPAWN_INTERVAL);
            } else {
                // Плавное движение к цели с учетом ускорения
                const targetX = shell.x - YACHT_CONFIG.width/2;
                const targetY = shell.y - YACHT_CONFIG.height/2;
                
                const currentInterpolation = YACHT_CONFIG.interpolation * 
                    (isSpeedBoosted ? SPEED_BOOST_MULTIPLIER : 1);
                
                yacht.x += (targetX - yacht.x) * currentInterpolation;
                yacht.y += (targetY - yacht.y) * currentInterpolation;

                // Ограничиваем движение яхты игровым полем
                yacht.x = Math.min(Math.max(yacht.x, gameOffsetX), 
                    gameOffsetX + gameWidth - YACHT_CONFIG.width);
                yacht.y = Math.min(Math.max(yacht.y, gameOffsetY), 
                    gameOffsetY + gameHeight - YACHT_CONFIG.height);
            }
        }

        function updateDina() {
            const currentTime = Date.now();
            const effectiveSpeed = DINA_CONFIG.speed * (1 / dina.scale);
            
            // Определяем, движется ли Дина
            dina.isMoving = controls.left || controls.right || controls.up || controls.down;

            // Обновляем направление спрайта
            if (controls.left) {
                DINA_CONFIG.facingLeft = true;
                dina.x = Math.max(gameOffsetX + DINA_CONFIG.baseSize/2 * dina.scale, 
                    dina.x - effectiveSpeed);
            }
            if (controls.right) {
                DINA_CONFIG.facingLeft = false;
                dina.x = Math.min(gameOffsetX + gameWidth - DINA_CONFIG.baseSize/2 * dina.scale, 
                    dina.x + effectiveSpeed);
            }
            if (controls.up) {
                dina.y = Math.max(gameOffsetY + DINA_CONFIG.baseSize/2 * dina.scale, 
                    dina.y - effectiveSpeed);
            }
            if (controls.down) {
                dina.y = Math.min(gameOffsetY + gameHeight - DINA_CONFIG.baseSize/2 * dina.scale, 
                    dina.y + effectiveSpeed);
            }

            // Обновляем анимацию только если Дина движется
            if (dina.isMoving && currentTime - dina.lastFrameUpdate > DINA_CONFIG.animationSpeed) {
                dina.currentFrame = (dina.currentFrame + 1) % DINA_CONFIG.frames;
                dina.lastFrameUpdate = currentTime;
            }
        }

        function drawDina() {
            const dinaSize = DINA_CONFIG.baseSize * dina.scale;
            
            // Сохраняем контекст перед трансформациями
            ctx.save();
            
            // Перемещаем точку отсчета в центр спрайта
            ctx.translate(dina.x, dina.y);
            
            // Если нужно отразить спрайт по горизонтали
            if (DINA_CONFIG.facingLeft) {
                ctx.scale(-1, 1);
            }

            // Рисуем текущий кадр анимации
            ctx.drawImage(
                resources.dina,
                dina.currentFrame * DINA_CONFIG.frameWidth, 0,  // координаты кадра в спрайтшите
                DINA_CONFIG.frameWidth, DINA_CONFIG.frameHeight,// размеры кадра в спрайтшите
                -dinaSize/2, -dinaSize/2,                      // позиция на экране
                dinaSize, dinaSize                             // размер отрисовки
            );

            // Восстанавливаем контекст
            ctx.restore();
        }

        function checkCollisions() {
            // Проверка столкновения с ракушкой
            if (shell.active) {
                const dinaRadius = (DINA_CONFIG.baseSize * dina.scale) / 2;
                const shellRadius = SHELL_CONFIG.size / 2;
                const dx = dina.x - (shell.x + shellRadius);
                const dy = dina.y - (shell.y + shellRadius);
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < dinaRadius + shellRadius) {
                    collectShell();
                }
            }

            // Проверка столкновения с яхтой - теперь только уменьшаем размер Дины
            const dinaRadius = (DINA_CONFIG.baseSize * dina.scale) / 2;
            const yachtRadius = Math.min(YACHT_CONFIG.width, YACHT_CONFIG.height) / 2;
            const dx = dina.x - (yacht.x + YACHT_CONFIG.width/2);
            const dy = dina.y - (yacht.y + YACHT_CONFIG.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < dinaRadius + yachtRadius) {
                dina.scale = DINA_CONFIG.minScale;
            }
        }

        function collectShell() {
            shell.active = false;
            shellsCollected++;
            
            if (dina.scale < DINA_CONFIG.maxScale) {
                dina.scale += DINA_CONFIG.scaleIncrement;
                if (dina.scale > DINA_CONFIG.maxScale) {
                    dina.scale = DINA_CONFIG.maxScale;
                }
            }

            if (shellsCollected % SHELLS_PER_LEVEL === 0 && level < MAX_LEVEL) {
                level++;
            }

            updateHUD();
            setTimeout(spawnShell, MIN_SHELL_SPAWN_INTERVAL);
        }

        function hitYacht() {
            // Функция больше не используется, оставляем пустой
            dina.scale = DINA_CONFIG.minScale;
        }

        // Функция для сохранения пропорций при отрисовке
        function drawImageMaintainAspectRatio(ctx, image, x, y, targetWidth, targetHeight) {
            if (!image.complete || !image.naturalWidth) return;

            const imageRatio = image.naturalWidth / image.naturalHeight;
            let width = targetWidth;
            let height = targetHeight;

            // Корректируем размеры, сохраняя пропорции
            if (targetWidth / targetHeight > imageRatio) {
                width = targetHeight * imageRatio;
            } else {
                height = targetWidth / imageRatio;
            }

            // Центрируем изображение в целевой области
            const x_offset = (targetWidth - width) / 2;
            const y_offset = (targetHeight - height) / 2;

            ctx.drawImage(image, 
                x + x_offset, y + y_offset,
                width, height);
        }

        function gameLoop() {
            if (!isGameRunning) return;

            // Очищаем канвас
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Проверяем и отрисовываем фон
            const currentBg = resources.backgrounds[level - 1];
            if (currentBg && currentBg.complete && currentBg.naturalWidth) {
                ctx.drawImage(currentBg, gameOffsetX, gameOffsetY, gameWidth, gameHeight);
            } else {
                console.warn('Background not ready:', level);
            }

            updateDina();
            updateYacht();
            checkCollisions();

            // Рисуем ракушку с проверкой
            if (shell.active && resources.shell.complete && resources.shell.naturalWidth) {
                ctx.drawImage(resources.shell, 
                    shell.x, shell.y, 
                    SHELL_CONFIG.size, SHELL_CONFIG.size);
            }

            // Рисуем Дину с проверкой
            if (resources.dina.complete && resources.dina.naturalWidth) {
                drawDina();
            } else {
                console.warn('Dina sprite not ready');
            }

            // Рисуем яхту с проверкой
            if (resources.yacht.complete && resources.yacht.naturalWidth) {
                ctx.drawImage(resources.yacht,
                    yacht.x, yacht.y,
                    YACHT_CONFIG.width, YACHT_CONFIG.height);
            } else {
                console.warn('Yacht sprite not ready');
            }

            // Отрисовка границ игрового поля
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.strokeRect(gameOffsetX, gameOffsetY, gameWidth, gameHeight);

            requestAnimationFrame(gameLoop);
        }

        function startTimer() {
            setInterval(() => {
                if (isGameRunning) {
                    timeElapsed++;
                    levelTimeElapsed++;

                    // Проверяем, нужно ли ускорить яхту
                    const timeLeftInLevel = LEVEL_DURATION - levelTimeElapsed;
                    if (timeLeftInLevel <= SPEED_BOOST_TIME && !isSpeedBoosted) {
                        isSpeedBoosted = true;
                        console.log('Speed boost activated!');
                    }

                    // Проверяем окончание уровня
                    if (levelTimeElapsed >= LEVEL_DURATION) {
                        levelTimeElapsed = 0;
                        isSpeedBoosted = false;
                        if (level < MAX_LEVEL) {
                            level++;
                            console.log('Level up:', level);
                        } else {
                            // Конец игры
                            isGameRunning = false;
                            console.log('Game Over!');
                        }
                    }

                    updateTimer();
                }
            }, 1000);
        }

        function updateTimer() {
            const timeLeftInLevel = LEVEL_DURATION - levelTimeElapsed;
            const minutes = Math.floor(timeLeftInLevel / 60);
            const seconds = timeLeftInLevel % 60;
            document.getElementById('timeText').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateHUD() {
            document.getElementById('scoreText').textContent = shellsCollected;
            document.getElementById('levelText').textContent = level;
        }

        function updateHUDPosition() {
            const hud = document.getElementById('hud');
            if (hud) {
                hud.style.left = gameOffsetX + 'px';
                hud.style.width = gameWidth + 'px';
            }
        }

        function updateSoundButtonPosition() {
            const soundToggle = document.getElementById('soundToggle');
            if (soundToggle) {
                soundToggle.style.transform = `translateX(-${gameOffsetX}px)`;
            }
        }

        // Обработчики событий управления
        function setupControls() {
            // Клавиатура
            window.addEventListener('keydown', e => {
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'Left':
                        controls.left = true;
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'Right':
                        controls.right = true;
                        e.preventDefault();
                        break;
                    case 'ArrowUp':
                    case 'Up':
                        controls.up = true;
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 'Down':
                        controls.down = true;
                        e.preventDefault();
                        break;
                }
                tryPlayAudio();
            });

            window.addEventListener('keyup', e => {
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'Left':
                        controls.left = false;
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'Right':
                        controls.right = false;
                        e.preventDefault();
                        break;
                    case 'ArrowUp':
                    case 'Up':
                        controls.up = false;
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 'Down':
                        controls.down = false;
                        e.preventDefault();
                        break;
                }
            });

            // Сенсорное управление
            const buttons = {
                btnLeft: 'left',
                btnRight: 'right',
                btnUp: 'up',
                btnDown: 'down'
            };

            Object.entries(buttons).forEach(([id, control]) => {
                const button = document.getElementById(id);
                if (button) {
                    button.addEventListener('touchstart', e => {
                        e.preventDefault();
                        controls[control] = true;
                        tryPlayAudio();
                    });
                    button.addEventListener('touchend', e => {
                        e.preventDefault();
                        controls[control] = false;
                    });
                }
            });

            // Управление звуком
            const soundToggle = document.getElementById('soundToggle');
            if (soundToggle) {
                soundToggle.addEventListener('click', () => {
                    soundEnabled = !soundEnabled;
                    const img = soundToggle.querySelector('img');
                    if (img) {
                        img.src = soundEnabled ? './icons/sound-on.png' : './icons/sound-off.png';
                    }
                    if (soundEnabled) {
                        tryPlayAudio();
                    } else {
                        resources.audio.pause();
                    }
                });
            }
        }

        function tryPlayAudio() {
            if (soundEnabled && resources.audio.paused) {
                resources.audio.play().catch(() => {
                    // Игнорируем ошибку автовоспроизведения
                });
            }
        }

        // Запуск игры
        setupControls();
        initGame();
    </script>
</body>
</html>
